<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è‚¡ç¥¨ç†±åŠ›åœ–ï¼ˆå¯ä¸Šå‚³ / å¯åˆ†äº«ï¼‰</title>

  <!-- Plotly Treemap -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <!-- CSV parser -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Excel parser -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- URL-friendly compression -->
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

  <style>
    :root { --border:#e5e7eb; --muted:#6b7280; }
    body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", sans-serif; }
    header { padding: 14px 16px; border-bottom: 1px solid var(--border); }
    h1 { margin: 0; font-size: 18px; }
    .muted { color: var(--muted); font-size: 13px; margin-top: 6px; line-height: 1.5; }
    .bar { display:flex; gap:10px; flex-wrap: wrap; padding: 12px 16px; border-bottom: 1px solid var(--border); align-items: center; }
    button { padding: 8px 10px; border: 1px solid var(--border); background: #fff; border-radius: 10px; cursor:pointer; }
    button:hover { background:#f9fafb; }
    input[type="file"] { padding: 6px 0; }
    input[type="text"], select {
      padding: 8px 10px; border: 1px solid var(--border); border-radius: 10px;
      min-width: 260px; background:#fff;
    }
    #msg { padding: 0 16px 10px; color: #b91c1c; font-size: 13px; min-height: 18px; }
    #chart { height: calc(100vh - 170px); }
    .ok { color: #047857 !important; }
    .drop {
      margin: 10px 16px 0;
      border: 2px dashed var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      color: var(--muted);
      font-size: 13px;
    }
    .pill { font-size:12px; padding:3px 8px; border:1px solid var(--border); border-radius:999px; color:var(--muted); }
  </style>
</head>

<body>
  <header>
    <h1>è‚¡ç¥¨ç†±åŠ›åœ–ï¼ˆä¸Šå‚³è³‡æ–™ â†’ ç”¢ç”Ÿåˆ†äº«é€£çµï¼‰</h1>
    <div class="muted">
      é è¨­æœƒå˜—è©¦è®€å–åŒè³‡æ–™å¤¾çš„ <b>data.csv</b>ã€‚å¯æ‹–æ‹‰/é¸æª”ä¸Šå‚³ CSV/XLSX/JSONã€‚
      ã€Œç”¢ç”Ÿåˆ†äº«é€£çµã€æœƒæŠŠè³‡æ–™å£“ç¸®å¾Œæ”¾é€²ç¶²å€ <b>#hash</b>ï¼ˆé©åˆå°ä¸­å‹è³‡æ–™é›†ï¼‰ã€‚
      <span class="pill">æç¤ºï¼šå¤ªå¤šæª”ï¼ˆä¾‹å¦‚ä¸Šåƒæª”ï¼‰URL å¯èƒ½éé•·ï¼Œå»ºè­°æ”¹ç”¨ã€Œå¾ç¶²å€è¼‰å…¥ CSVã€</span>
    </div>
  </header>

  <div class="bar">
    <input id="file" type="file" accept=".csv,.xlsx,.xls,.json" />
    <button id="btnLoadDefault">è¼‰å…¥ï¼ˆæˆ–é‡è¼‰ï¼‰data.csv</button>

    <label class="muted" style="margin-left:4px;">é¡¯ç¤ºæ¨¡å¼ï¼š</label>
    <select id="mode">
      <option value="none">å–®å±¤ï¼šé¡è‚¡ â†’ è‚¡ç¥¨</option>
      <option value="subcol">é›™å±¤ï¼šé¡è‚¡ â†’ å­åˆ†é¡æ¬„ä½ â†’ è‚¡ç¥¨</option>
      <option value="amountbin">é›™å±¤ï¼šé¡è‚¡ â†’ æˆäº¤é¡åˆ†ç´šï¼ˆå¤§/ä¸­/å°ï¼‰â†’ è‚¡ç¥¨</option>
    </select>

    <button id="btnShare">ç”¢ç”Ÿåˆ†äº«é€£çµ</button>
    <button id="btnCopy" disabled>è¤‡è£½åˆ†äº«é€£çµ</button>

    <span class="muted">æˆ–å¾ç¶²å€è¼‰å…¥ CSVï¼š</span>
    <input id="csvUrl" type="text" placeholder="è²¼ä¸Š data.csv çš„å…¬é–‹ç¶²å€ï¼ˆrawï¼‰" />
    <button id="btnLoadUrl">å¾ç¶²å€è¼‰å…¥</button>
  </div>

  <div class="drop">ğŸ“¥ ä½ ä¹Ÿå¯ä»¥æŠŠæª”æ¡ˆç›´æ¥æ‹–æ›³åˆ°é€™å€‹é é¢ä»»ä½•ä½ç½®æ”¾é–‹ï¼ˆCSV / XLSX / JSONï¼‰ã€‚</div>
  <div id="msg"></div>
  <div id="chart"></div>

<script>
  const $msg = document.getElementById('msg');
  const $file = document.getElementById('file');
  const $btnLoadDefault = document.getElementById('btnLoadDefault');
  const $btnShare = document.getElementById('btnShare');
  const $btnCopy = document.getElementById('btnCopy');
  const $csvUrl = document.getElementById('csvUrl');
  const $btnLoadUrl = document.getElementById('btnLoadUrl');
  const $mode = document.getElementById('mode');

  let lastRows = null;     // normalized rows
  let lastMode = 'none';   // current mode

  function setMsg(text, ok=false) {
    $msg.textContent = text || '';
    $msg.className = ok ? 'ok' : '';
  }

  function toNumber(x) {
    if (x === null || x === undefined) return NaN;
    if (typeof x === 'number') return x;
    const s = String(x)
      .trim()
      .replace(/,/g,'')      // 1,234
      .replace(/ï¼…/g,'%')    // fullwidth
      .replace(/%/g,'');     // pct sign
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  function pickColumn(headers, candidates) {
    const lower = headers.map(h => String(h).trim().toLowerCase());
    for (const c of candidates) {
      const idx = lower.indexOf(String(c).toLowerCase());
      if (idx >= 0) return headers[idx];
    }
    return null;
  }

  // æˆäº¤é¡åˆ†ç´šï¼ˆå¤§/ä¸­/å°ï¼‰ï¼šç”¨ value çš„åˆ†ä½æ•¸
  function amountBucket(v, q1, q2) {
    if (!Number.isFinite(v)) return 'æœªçŸ¥';
    if (v >= q2) return 'å¤§';
    if (v >= q1) return 'ä¸­';
    return 'å°';
  }

  function quantiles(values) {
    const xs = values.filter(Number.isFinite).slice().sort((a,b)=>a-b);
    if (xs.length === 0) return {q1:0, q2:0};
    const q = (p) => {
      const idx = (xs.length - 1) * p;
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return xs[lo];
      const t = idx - lo;
      return xs[lo] * (1 - t) + xs[hi] * t;
    };
    return {q1: q(0.33), q2: q(0.66)};
  }

  function normalizeRows(rawRows, mode) {
    if (!Array.isArray(rawRows) || rawRows.length === 0) throw new Error('æ²’æœ‰è®€åˆ°ä»»ä½•è³‡æ–™åˆ—ã€‚');

    const headers = Object.keys(rawRows[0] || {});
    if (headers.length === 0) throw new Error('æ‰¾ä¸åˆ°æ¬„ä½ï¼ˆheaderï¼‰ã€‚');

    const colGroup  = pickColumn(headers, ['group','sector','industry','åˆ†é¡','ç”¢æ¥­','é¡åˆ¥','é¡è‚¡']);
    const colSub    = pickColumn(headers, ['sub','subgroup','sub_group','subsector','sub_sector','å­åˆ†é¡','å­ç”¢æ¥­','æ¬¡åˆ†é¡','æ¬¡ç”¢æ¥­','ç´°åˆ†','ç´°é …']);
    const colSymbol = pickColumn(headers, ['symbol','ticker','code','ä»£ç¢¼','è‚¡ç¥¨','stock','name','åç¨±']);
    const colValue  = pickColumn(headers, ['value','size','market_cap','marketcap','weight','å¸‚å€¼','æ¬Šé‡','æˆäº¤é‡‘é¡','æˆäº¤é¡','amount','turnover']);
    const colChange = pickColumn(headers, ['change','chg','return','pct','perf','æ¼²è·Œ','æ¼²è·Œå¹…','å ±é…¬','å ±é…¬ç‡','è®Šå‹•']);

    if (!colSymbol) throw new Error('æ‰¾ä¸åˆ°ã€Œsymbolã€æ¬„ä½ï¼ˆå¯æ¥å—ï¼šsymbol/ticker/code/ä»£ç¢¼/è‚¡ç¥¨ï¼‰ã€‚');
    if (!colChange) throw new Error('æ‰¾ä¸åˆ°ã€Œchangeã€æ¬„ä½ï¼ˆå¯æ¥å—ï¼šchange/return/pct/æ¼²è·Œå¹…ï¼‰ã€‚');

    // å…ˆåšåŸºæœ¬è½‰æ›
    let rows = rawRows.map((r) => {
      const group = colGroup ? String(r[colGroup] ?? 'æœªåˆ†é¡').trim() : 'æœªåˆ†é¡';
      const symbol = String(r[colSymbol] ?? '').trim();
      const value = colValue ? toNumber(r[colValue]) : 1;
      const change = toNumber(r[colChange]);

      if (!symbol) return null;
      return {
        group,
        symbol,
        value: Number.isFinite(value) && value > 0 ? value : 1,
        change: Number.isFinite(change) ? change : 0,
        sub: '' // å¾Œé¢å†æ±ºå®š
      };
    }).filter(Boolean);

    if (rows.length === 0) throw new Error('è³‡æ–™åˆ—è§£æå¾Œç‚ºç©ºï¼ˆå¯èƒ½ symbol æ¬„ä½éƒ½æ˜¯ç©ºçš„ï¼‰ã€‚');

    // mode æ±ºå®šç¬¬äºŒå±¤
    if (mode === 'subcol') {
      if (!colSub) throw new Error('ä½ é¸äº†ã€Œå­åˆ†é¡æ¬„ä½ã€æ¨¡å¼ï¼Œä½†è³‡æ–™æ‰¾ä¸åˆ°å­åˆ†é¡æ¬„ä½ï¼ˆå¯æ¥å—ï¼šsub/subgroup/å­åˆ†é¡/å­ç”¢æ¥­/æ¬¡åˆ†é¡â€¦ï¼‰ã€‚');
      rows = rows.map(r => ({...r, sub: String(rawRows.find(x => String(x[colSymbol]??'').trim() === r.symbol)?.[colSub] ?? 'æœªåˆ†é¡').trim() || 'æœªåˆ†é¡'}));
      return rows;
    }

    if (mode === 'amountbin') {
      // ç”¨æ¯å€‹é¡è‚¡å…§çš„ value åˆ†ä½æ•¸ä¾†åˆ‡ï¼ˆæ¯”è¼ƒç¬¦åˆã€Œé¡è‚¡å…§å¤§å°ã€ï¼‰
      const byGroup = new Map();
      for (const r of rows) {
        if (!byGroup.has(r.group)) byGroup.set(r.group, []);
        byGroup.get(r.group).push(r.value);
      }
      const qMap = new Map();
      for (const [g, vs] of byGroup.entries()) qMap.set(g, quantiles(vs));
      rows = rows.map(r => {
        const {q1, q2} = qMap.get(r.group) || {q1:0,q2:0};
        return {...r, sub: `æˆäº¤é¡${amountBucket(r.value, q1, q2)}`}; // æˆäº¤é¡å¤§/ä¸­/å°
      });
      return rows;
    }

    // noneï¼šä¸åšç¬¬äºŒå±¤
    return rows;
  }

  function buildTreemap(rows, mode) {
    // ç”¨ ids é¿å… label é‡è¤‡è¢«åˆä½µ
    const ids = [];
    const labels = [];
    const parents = [];
    const values = [];
    const colors = [];

    const ROOT_ID = 'root';
    ids.push(ROOT_ID); labels.push('å…¨éƒ¨'); parents.push(''); values.push(0); colors.push(0);

    // group aggregation
    const groupAgg = new Map(); // group -> {value, wchg}
    const subAgg = new Map();   // group|sub -> {value, wchg}

    for (const r of rows) {
      const gKey = r.group;
      if (!groupAgg.has(gKey)) groupAgg.set(gKey, {value:0, wchg:0});
      const g = groupAgg.get(gKey);
      g.value += r.value;
      g.wchg += r.change * r.value;

      if (mode !== 'none') {
        const sKey = `${r.group}||${r.sub || 'æœªåˆ†é¡'}`;
        if (!subAgg.has(sKey)) subAgg.set(sKey, {value:0, wchg:0, group:r.group, sub:(r.sub || 'æœªåˆ†é¡')});
        const s = subAgg.get(sKey);
        s.value += r.value;
        s.wchg += r.change * r.value;
      }
    }

    // push groups
    for (const [gname, g] of groupAgg.entries()) {
      const gid = `g|${gname}`;
      ids.push(gid);
      labels.push(gname);
      parents.push(ROOT_ID);
      values.push(g.value);
      colors.push(g.value ? (g.wchg / g.value) : 0);
    }

    // push subgroups (if any)
    if (mode !== 'none') {
      for (const s of subAgg.values()) {
        const sid = `s|${s.group}|${s.sub}`;
        ids.push(sid);
        labels.push(s.sub);
        parents.push(`g|${s.group}`);
        values.push(s.value);
        colors.push(s.value ? (s.wchg / s.value) : 0);
      }
    }

    // push leaves
    for (const r of rows) {
      const parentId = (mode === 'none')
        ? `g|${r.group}`
        : `s|${r.group}|${r.sub || 'æœªåˆ†é¡'}`;

      const lid = `l|${r.group}|${r.sub || ''}|${r.symbol}`;
      ids.push(lid);
      labels.push(r.symbol);
      parents.push(parentId);
      values.push(r.value);
      colors.push(r.change);
    }

    // root total
    values[0] = Array.from(groupAgg.values()).reduce((s,x)=>s+x.value,0);
    return {ids, labels, parents, values, colors};
  }

  function render(rawRowsOrNormalized) {
    const mode = $mode.value;
    lastMode = mode;

    // å¦‚æœå‚³é€²ä¾†çš„æ˜¯ already-normalized rowsï¼ˆå¾ hashï¼‰ï¼Œå°±ç›´æ¥ç”¨
    const rows = (rawRowsOrNormalized && rawRowsOrNormalized.length && rawRowsOrNormalized[0].hasOwnProperty('group') && rawRowsOrNormalized[0].hasOwnProperty('symbol'))
      ? rawRowsOrNormalized
      : normalizeRows(rawRowsOrNormalized, mode);

    lastRows = rows;

    const {ids, labels, parents, values, colors} = buildTreemap(rows, mode);

    const data = [{
      type: 'treemap',
      ids,
      labels,
      parents,
      values,
      branchvalues: 'total',
      marker: {
        colors,
        colorscale: [
          [0,'#1a9641'],
          [0.5,'#ffffff'],
          [1,'#d7191c']
        ],
        cmid: 0,
        line: { width: 1, color: '#ffffff' }
      },
      hovertemplate:
        '<b>%{label}</b><br>' +
        'ä¸Šå±¤ï¼š%{parent}<br>' +
        'å¤§å°ï¼š%{value}<br>' +
        'è®Šå‹•ï¼š%{color:.2f}<extra></extra>'
    }];

    Plotly.newPlot('chart', data, {margin:{l:10,r:10,t:10,b:10}}, {responsive:true, displaylogo:false});
    setMsg('å·²æ›´æ–°ç†±åŠ›åœ–ã€‚', true);
    $btnCopy.disabled = true;
  }

  function loadCSVText(text) {
    const parsed = Papa.parse(text, {header: true, skipEmptyLines: true});
    if (parsed.errors && parsed.errors.length) {
      throw new Error('CSV è§£æéŒ¯èª¤ï¼š' + parsed.errors[0].message);
    }
    return parsed.data;
  }

  async function handleFile(file) {
    setMsg('');
    const name = (file.name || '').toLowerCase();
    const buf = await file.arrayBuffer();

    if (name.endsWith('.csv')) {
      const text = new TextDecoder('utf-8').decode(buf);
      render(loadCSVText(text));
      return;
    }
    if (name.endsWith('.json')) {
      const text = new TextDecoder('utf-8').decode(buf);
      const raw = JSON.parse(text);
      const rawRows = Array.isArray(raw) ? raw : (raw.rows || raw.data || []);
      render(rawRows);
      return;
    }
    if (name.endsWith('.xlsx') || name.endsWith('.xls')) {
      const wb = XLSX.read(buf, {type: 'array'});
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const rawRows = XLSX.utils.sheet_to_json(sheet, {defval: ''});
      render(rawRows);
      return;
    }
    throw new Error('ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ã€‚è«‹ç”¨ CSV / XLSX / JSONã€‚');
  }

  function makeShareLink(mode, rows) {
    const payload = {v: 2, mode, rows};
    const json = JSON.stringify(payload);
    const compressed = LZString.compressToEncodedURIComponent(json);
    return `${location.origin}${location.pathname}#data=${compressed}`;
  }

  function tryLoadFromHash() {
    const hash = location.hash || '';
    if (!hash.startsWith('#data=')) return false;
    try {
      const encoded = hash.slice(6);
      const json = LZString.decompressFromEncodedURIComponent(encoded);
      const payload = JSON.parse(json);

      // ç›¸å®¹èˆŠç‰ˆ v1
      if (payload && payload.v === 1 && Array.isArray(payload.rows)) {
        $mode.value = 'none';
        render(payload.rows);
        setMsg('å·²å¾åˆ†äº«é€£çµè¼‰å…¥è³‡æ–™ï¼ˆèˆŠç‰ˆ v1ï¼‰ã€‚', true);
        return true;
      }

      if (!payload || !Array.isArray(payload.rows)) throw new Error('hash å…§å®¹ä¸æ­£ç¢º');
      if (payload.mode) $mode.value = payload.mode;

      render(payload.rows); // rows å·²æ˜¯ normalized
      setMsg('å·²å¾åˆ†äº«é€£çµè¼‰å…¥è³‡æ–™ã€‚', true);
      return true;
    } catch (e) {
      setMsg('åˆ†äº«é€£çµè§£æå¤±æ•—ï¼š' + (e?.message || e));
      return false;
    }
  }

  async function loadFromUrl(url) {
    setMsg('');
    if (!url) throw new Error('è«‹è²¼ä¸Š CSV çš„å…¬é–‹ç¶²å€ã€‚');
    const res = await fetch(url, {cache: 'no-store'});
    if (!res.ok) throw new Error(`æŠ“å–å¤±æ•—ï¼šHTTP ${res.status}`);
    const text = await res.text();
    render(loadCSVText(text));
  }

  async function loadDefaultCSV() {
    try {
      const res = await fetch('./data.csv', {cache: 'no-store'});
      if (!res.ok) throw new Error(`æŠ“å– data.csv å¤±æ•—ï¼šHTTP ${res.status}`);
      const text = await res.text();
      render(loadCSVText(text));
      setMsg('å·²è¼‰å…¥ data.csvã€‚', true);
    } catch (e) {
      setMsg('è¼‰å…¥ data.csv å¤±æ•—ï¼ˆæœ¬æ©Ÿ file:// å¸¸è¦‹é™åˆ¶ï¼Œéƒ¨ç½²åˆ° Pages å°±æ­£å¸¸ï¼‰ï¼š' + (e?.message || e));
    }
  }

  // events
  $file.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try { await handleFile(f); }
    catch (err) { setMsg(err?.message || String(err)); }
  });

  // drag & drop
  window.addEventListener('dragover', (e) => { e.preventDefault(); });
  window.addEventListener('drop', async (e) => {
    e.preventDefault();
    const f = e.dataTransfer?.files?.[0];
    if (!f) return;
    try { await handleFile(f); }
    catch (err) { setMsg(err?.message || String(err)); }
  });

  $btnLoadDefault.addEventListener('click', loadDefaultCSV);

  // æ”¹æ¨¡å¼ï¼šç›´æ¥ç”¨ lastRows é‡æ–°ç•«ï¼ˆå¦‚æœ lastRows æ˜¯ normalizedï¼Œæ¨¡å¼åˆ‡æ›éœ€è¦å›åˆ° raw æ‰èƒ½é‡ç®— subï¼‰
  // ç°¡åŒ–åšæ³•ï¼šæç¤ºä½¿ç”¨è€…åˆ‡æ›æ¨¡å¼å¾Œé‡è¼‰æª”æ¡ˆ/URL æˆ– data.csv
  $mode.addEventListener('change', () => {
    setMsg('å·²åˆ‡æ›é¡¯ç¤ºæ¨¡å¼ã€‚å»ºè­°é‡æ–°è¼‰å…¥æª”æ¡ˆï¼ˆæˆ–é‡è¼‰ data.csvï¼‰ä»¥å¥—ç”¨æ–°æ¨¡å¼ã€‚', true);
    $btnCopy.disabled = true;
  });

  document.getElementById('btnShare').addEventListener('click', () => {
    try {
      if (!lastRows) throw new Error('è«‹å…ˆä¸Šå‚³è³‡æ–™æˆ–æˆåŠŸè¼‰å…¥ data.csvã€‚');
      const url = makeShareLink($mode.value, lastRows);
      location.hash = url.split('#')[1];
      setMsg('å·²ç”¢ç”Ÿåˆ†äº«é€£çµï¼ˆè³‡æ–™å·²å¯«å…¥ç¶²å€ #hashï¼‰ã€‚å¯æŒ‰ã€Œè¤‡è£½åˆ†äº«é€£çµã€ã€‚', true);
      $btnCopy.disabled = false;
    } catch (err) {
      setMsg(err?.message || String(err));
    }
  });

  $btnCopy.addEventListener('click', async () => {
    try {
      const url = `${location.origin}${location.pathname}${location.hash}`;
      await navigator.clipboard.writeText(url);
      setMsg('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ã€‚', true);
    } catch (err) {
      setMsg('è¤‡è£½å¤±æ•—ï¼šä½ å¯ä»¥ç›´æ¥æ‰‹å‹•è¤‡è£½ç¶²å€åˆ—ã€‚');
    }
  });

  $btnLoadUrl.addEventListener('click', async () => {
    try { await loadFromUrl($csvUrl.value.trim()); }
    catch (err) { setMsg(err?.message || String(err)); }
  });

  // boot
  if (!tryLoadFromHash()) {
    loadDefaultCSV();
  }
</script>
</body>
</html>
